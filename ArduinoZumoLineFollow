#include <Wire.h>
#include <ZumoShield.h>
#include <Adafruit_MotorShield.h>


//ZumoBuzzer buzzer;
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
ZumoReflectanceSensorArray reflectanceSensorshort;
ZumoReflectanceSensorArray reflectanceSensorlong;
// Select which 'port' M1, M2, M3 or M4. In this case, M1
Adafruit_DCMotor *M1 = AFMS.getMotor(1);
// You can also make another motor on port M2
Adafruit_DCMotor *M2 = AFMS.getMotor(2);
Adafruit_DCMotor *M3 = AFMS.getMotor(3);
Adafruit_DCMotor *M4 = AFMS.getMotor(4);

char dir = FORWARD;
const int speedi = 150;
const int slow = 100;
const int threshold = 1700;
int shortroad = 1;

void setup() {
  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz
  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz
    Serial.println("Could not find Motor Shield. Check wiring.");
    while (1);
  }
  Serial.println("Motor Shield found.");

   byte pins[] = {6,12,A1,7};
   byte pinsl[] = {4,11,A0,5};
  reflectanceSensorshort.init(pins,4);
  reflectanceSensorlong.init(pinsl,4);
  reflectanceSensorshort.calibrate();
  delay(20);

  Serial.begin(115200);
  
  //start going forward
  M1->run(FORWARD);
  M2->run(FORWARD);
  M1->setSpeed(speedi);
  M2->setSpeed(speedi);
  M3->setSpeed(0);
  M4->setSpeed(0);
  //delay(100); //enough to get out of white square
}
void turnleftshort(unsigned int sensorValues[]){
   M3->run(BACKWARD);
   M4->run(BACKWARD);
   M1->run(RELEASE);
   M2->run(RELEASE);
   M3->setSpeed(slow);
   M4->setSpeed(slow);
}

//when on short road, turn right
void turnrightshort(unsigned int sensorValues[]){
  M3->run(FORWARD);
  M4->run(FORWARD);
  M1->run(RELEASE);
  M2->run(RELEASE);
  M3->setSpeed(slow);
  M4->setSpeed(slow);
}

void turnleftlong(unsigned int sensorValues[]){
   M1->run(BACKWARD);
   M2->run(BACKWARD);
   M3->run(RELEASE);
   M4->run(RELEASE);
   M1->setSpeed(slow);
   M2->setSpeed(slow);
}

//when on long road, turn right
void turnrightlong(unsigned int sensorValues[]){
  M1->run(FORWARD);
  M2->run(FORWARD);
  M3->run(RELEASE);
  M4->run(RELEASE);
  M1->setSpeed(slow);
  M2->setSpeed(slow);
  
}

void lost(){
  M1->run(RELEASE);
  M2->run(RELEASE);
  M3->run(RELEASE);
  M4->run(RELEASE);
  
  M3->setSpeed(0);
  M4->setSpeed(0);
  M1->setSpeed(0);
  M2->setSpeed(0);
}
//0->3
   //right to left

void checkturnshort(unsigned int sensorValues[]){
  if (sensorValues[0] <= threshold){
    reflectanceSensorlong.read(sensorValues,QTR_EMITTERS_ON);
    while (sensorValues[1] > threshold || sensorValues[2] > threshold){
      M1->run(BACKWARD);
      M2->run(BACKWARD);
      M3->run(RELEASE);
      M4->run(RELEASE);
      M1->setSpeed(slow);
      M2->setSpeed(slow);
    }
    M3->run(FORWARD);
    M4->run(FORWARD);
    M1->run(RELEASE);
    M2->run(RELEASE);
    M3->setSpeed(speedi);
    M4->setSpeed(speedi);
    shortroad = 0;
  }
  else{
    M1->run(dir);
    M2->run(dir);
    M3->run(RELEASE);
    M4->run(RELEASE);
    M1->setSpeed(speedi);
    M2->setSpeed(speedi);
  }
}

void checkturnlong(unsigned int sensorValues[]){
  //check distance sensor here
  if (sensorValues[0] <= threshold){
    M3->run(FORWARD);
    M4->run(FORWARD);
    M1->run(RELEASE);
    M2->run(RELEASE);
    M3->setSpeed(speedi);
    M4->setSpeed(speedi);
    shortroad = 1;
  }
  else{
    M3->run(dir);
    M4->run(dir);
    M1->run(RELEASE);
    M2->run(RELEASE);
    M3->setSpeed(speedi);
    M4->setSpeed(speedi);
  }
}

void loop() {
  unsigned int sensorValues[4];
  static uint16_t lastSampleTime = 0;

  //if it has been 100ms
  if ((uint16_t)(millis() - lastSampleTime) >= 100)
  {
    lastSampleTime = millis();
    
    if (shortroad == 0){
      reflectanceSensorlong.read(sensorValues,QTR_EMITTERS_ON);
    }
    else{
      reflectanceSensorshort.read(sensorValues,QTR_EMITTERS_ON);
    }
    
  }
   if (sensorValues[1] <= threshold){ 
    if (sensorValues[2] <= threshold){
      if (shortroad == 1){
        if (sensorValues[0] <= threshold && sensorValues[3] <= threshold){
          M1->run(BACKWARD);
          M2->run(BACKWARD);
          M3->run(RELEASE);
          M4->run(RELEASE);
          M1->setSpeed(speedi);
          M2->setSpeed(speedi);
          M3->setSpeed(0);
          M4->setSpeed(0);
          delay(10); //enough to get fully in white square
          M1->run(RELEASE);
          M2->run(RELEASE);
          M1->setSpeed(0);
          M2->setSpeed(0);
          while(1){
            //trapped in here once done
          }
        }
        //if not all white, call checkturn
        else{
          checkturnshort(sensorValues);
        }
      }
      else{
        checkturnlong(sensorValues);
      }
    }
    else{
      if (shortroad == 0){
        turnrightlong(sensorValues);
      }
      else{
        turnrightshort(sensorValues);
      }
    }
   }
    else if (sensorValues[2] <= threshold){
      if (shortroad == 0){
        turnleftlong(sensorValues);
      }
      else{
      turnleftshort(sensorValues);
      }
    }
    /*else{
      lost();
    }*/
}
